<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Parser</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/api.js"></script>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
  <div class="container mx-auto p-4 md:p-6 max-w-6xl">
    <div class="bg-white rounded-2xl shadow-xl p-6 md:p-8 mb-6">
      <h1 class="text-2xl md:text-3xl font-bold text-gray-800 mb-2 flex items-center gap-3">
        <svg class="text-indigo-600" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        Event Parser
      </h1>
      <p class="text-gray-600 mb-6">Connect Gmail to auto-extract events from recent emails, or paste content manually</p>

      <!-- Gmail Integration Section -->
      <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold text-gray-800 flex items-center gap-2">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
              <polyline points="22,6 12,13 2,6"></polyline>
            </svg>
            Gmail Integration
          </h2>
          <div id="authButtons">
            <button
              id="signInBtn"
              class="px-4 py-2 bg-white border border-gray-300 rounded-lg font-semibold hover:bg-gray-50 flex items-center gap-2 transition-colors text-sm"
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
              </svg>
              Sign in with Google
            </button>
            <button
              id="signOutBtn"
              class="hidden px-4 py-2 bg-gray-600 text-white rounded-lg font-semibold hover:bg-gray-700 transition-colors text-sm"
            >
              Sign Out
            </button>
          </div>
        </div>
        <div id="userInfo" class="hidden mb-1 text-sm text-gray-600"></div>
        <div id="gmailControls" class="hidden">
          <button
            onclick="relinkEmails()"
            class="mt-2 px-3 py-1.5 bg-indigo-100 text-indigo-700 rounded-lg text-xs font-semibold hover:bg-indigo-200 transition-colors"
          >
            Fetch
          </button>
        </div>
      </div>

      <!-- URL fetch section -->
      <div class="mb-4 flex gap-2">
        <input
          id="urlInput"
          type="url"
          placeholder="Paste a website URL to extract events from…"
          class="flex-1 p-3 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none text-sm"
        />
        <button
          id="fetchUrlBtn"
          class="px-4 py-2 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors text-sm whitespace-nowrap"
        >
          Fetch URL
        </button>
      </div>

      <textarea
        id="emailInput"
        placeholder="Or paste email / page content here…"
        class="w-full h-64 p-4 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none font-mono text-sm resize-y"
      ></textarea>

      <div id="errorBox" class="hidden mt-4 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700"></div>

      <button
        id="parseBtn"
        class="mt-4 px-8 py-3 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center gap-2 transition-colors"
      >
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
        </svg>
        Extract Events
      </button>
    </div>

    <div id="eventsContainer" class="space-y-4"></div>
  </div>

  <script>
    // Configuration
    const GOOGLE_CLIENT_ID = '557433500490-cbm0sv985n4bopji202fojtvslsmpgol.apps.googleusercontent.com';
    const GMAIL_SCOPES = 'https://www.googleapis.com/auth/gmail.modify https://www.googleapis.com/auth/calendar.events';

    // Event scoring: emails must reach a minimum score to be treated as event emails.
    // Strong phrases score 3 (almost certainly an event invite).
    // Weak phrases score 1 (could appear in non-event mail, need corroboration).
    // Subject matches are worth 2× body matches.
    // Negative signals subtract points (receipts, account notifications, etc.).
    const STRONG_KEYWORDS = [
      'rsvp', 'webinar', 'symposium', 'save the date', "you're invited",
      'join us for', 'seminar', 'conference', 'workshop', 'lecture',
      'registration is open', 'register now', 'register here',
      'tickets available', 'reserve your spot', 'reserve your seat',
      'attend', 'attending', 'free admission', 'open to the public','event', 'talk'
    ];
    const WEAK_KEYWORDS = [
      'meeting', 'presentation', 'session',
      'invite', 'invitation', 'join us', 'calendar', 'register'
    ];
    // Date patterns: "March 15", "15 March", "3/15", "15th", "Tuesday,", etc.
    const DATE_PATTERN = /\b(\d{1,2}[\/\-]\d{1,2}|\d{1,2}(?:st|nd|rd|th)\b|(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\.?\s+\d{1,2}|\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*|(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday),?\s+\d)/i;
    const NEGATIVE_KEYWORDS = [
      'unsubscribe', 'order confirmation', 'order #', 'receipt', 'invoice',
      'shipment', 'tracking number', 'your password', 'reset your password',
      'verify your email', 'confirm your email', 'account created',
      'payment received', 'subscription renewal', 'auto-renewal',
      'statement is ready', 'your bill', 'two-factor', 'login attempt',
      'security alert', 'we noticed', 'sign in to your',
      'hep-th daily', 'digest'
    ];
    const MIN_SCORE = 3;

    // DOM Elements
    const parseBtn = document.getElementById('parseBtn');
    const emailInput = document.getElementById('emailInput');
    const urlInput = document.getElementById('urlInput');
    const fetchUrlBtn = document.getElementById('fetchUrlBtn');
    const errorBox = document.getElementById('errorBox');
    const eventsContainer = document.getElementById('eventsContainer');
    const signInBtn = document.getElementById('signInBtn');
    const signOutBtn = document.getElementById('signOutBtn');
    const userInfo = document.getElementById('userInfo');
    const gmailControls = document.getElementById('gmailControls');

    // Gmail state
    let gapiInitialized = false;
    let tokenClient;
    let accessToken = null;
    let tokenExpiresAt = null;

    // Events state
    let allEvents = JSON.parse(localStorage.getItem('extractedEvents') || '[]');

    // Track Gmail message IDs that have already been sent to AI processing
    let processedEmailIds = new Set(JSON.parse(localStorage.getItem('processedEmailIds') || '[]'));

    // Track event IDs that have been added to Google Calendar
    let addedEventIds = new Set(JSON.parse(localStorage.getItem('addedEventIds') || '[]'));

    // Restore saved access token
    function restoreSavedToken() {
      const savedToken = localStorage.getItem('gmailAccessToken');
      const savedExpiry = localStorage.getItem('gmailTokenExpiry');

      if (savedToken && savedExpiry) {
        const expiryTime = parseInt(savedExpiry);
        const now = Date.now();

        // Check if token is still valid (with 5 minute buffer)
        if (expiryTime > now + (5 * 60 * 1000)) {
          accessToken = savedToken;
          tokenExpiresAt = expiryTime;
          // Tell the gapi client to use this token for API calls
          if (typeof gapi !== 'undefined' && gapi.client) {
            gapi.client.setToken({ access_token: savedToken });
          }
          updateAuthUI(true);
          return true;
        } else {
          // Token expired, clear it
          clearSavedToken();
        }
      }
      return false;
    }

    function saveToken(token, expiresIn) {
      accessToken = token;
      // expiresIn is in seconds, convert to milliseconds and add to current time
      tokenExpiresAt = Date.now() + (expiresIn * 1000);
      // Tell the gapi client to use this token for API calls
      if (typeof gapi !== 'undefined' && gapi.client) {
        gapi.client.setToken({ access_token: token });
      }
      localStorage.setItem('gmailAccessToken', token);
      localStorage.setItem('gmailTokenExpiry', tokenExpiresAt.toString());
    }

    function clearSavedToken() {
      accessToken = null;
      tokenExpiresAt = null;
      if (typeof gapi !== 'undefined' && gapi.client) {
        gapi.client.setToken(null);
      }
      localStorage.removeItem('gmailAccessToken');
      localStorage.removeItem('gmailTokenExpiry');
    }

    // Initialize Google API
    function gapiLoaded() {
      gapi.load('client', initializeGapiClient);
    }

    async function initializeGapiClient() {
      await gapi.client.init({
        discoveryDocs: [
          'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest',
          'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest',
        ],
      });
      gapiInitialized = true;
    }

    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GOOGLE_CLIENT_ID,
        scope: GMAIL_SCOPES,
        callback: (response) => {
          if (response.error) {
            // Silent re-auth failed (e.g. user revoked access) — just show sign-in button
            if (response.error !== 'interaction_required' && response.error !== 'user_cancelled') {
              showError('Failed to authenticate with Google');
            }
            clearSavedToken();
            localStorage.removeItem('gmailUserSignedIn');
            updateAuthUI(false);
            return;
          }
          saveToken(response.access_token, response.expires_in);
          localStorage.setItem('gmailUserSignedIn', 'true');
          updateAuthUI(true);
        },
      });
    }

    // Sign in/out handlers
    signInBtn.addEventListener('click', () => {
      if (!tokenClient) {
        showError('Google Sign-In not ready yet. Please wait a moment and try again.');
        return;
      }
      tokenClient.requestAccessToken();
    });

    signOutBtn.addEventListener('click', () => {
      if (accessToken) google.accounts.oauth2.revoke(accessToken);
      clearSavedToken();
      localStorage.removeItem('gmailUserSignedIn');
      updateAuthUI(false);
    });

    function updateAuthUI(isSignedIn) {
      if (isSignedIn) {
        signInBtn.classList.add('hidden');
        signOutBtn.classList.remove('hidden');
        userInfo.classList.remove('hidden');
        gmailControls.classList.remove('hidden');
        userInfo.textContent = '✓ Connected to Gmail';
      } else {
        signInBtn.classList.remove('hidden');
        signOutBtn.classList.add('hidden');
        userInfo.classList.add('hidden');
        gmailControls.classList.add('hidden');
      }
    }

    function gapiError(err) {
      // GAPI errors are objects like { result: { error: { message } }, status }
      return err?.result?.error?.message || err?.message || JSON.stringify(err);
    }

    // Fetch emails from the past week
    async function autoFetchRecentEmails() {
      if (!accessToken) return;

      // Wait for the GAPI client to finish initialising (it loads asynchronously)
      if (!gapiInitialized) {
        await new Promise(resolve => {
          const poll = setInterval(() => {
            if (gapiInitialized) { clearInterval(poll); resolve(); }
          }, 100);
        });
      }

      // Ensure the token is set on the gapi client (in case it was restored before gapi loaded)
      gapi.client.setToken({ access_token: accessToken });

      userInfo.innerHTML = '⏳ Fetching emails from the past week...';

      try {
        // Calculate date 1 week ago
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
        const dateString = `${oneWeekAgo.getFullYear()}/${String(oneWeekAgo.getMonth() + 1).padStart(2, '0')}/${String(oneWeekAgo.getDate()).padStart(2, '0')}`;

        const response = await gapi.client.gmail.users.messages.list({
          userId: 'me',
          maxResults: 500, // Increased limit to get all emails from the past week
          q: `after:${dateString}` // Only emails from the past week
        });

        const messages = response.result.messages || [];

        if (messages.length === 0) {
          userInfo.innerHTML = '✓ Connected to Gmail (No emails found)';
          return;
        }

        // Fetch full email details in batches of 10 to avoid Gmail concurrency limits
        const BATCH_SIZE = 10;
        const emails = [];
        for (let i = 0; i < messages.length; i += BATCH_SIZE) {
          const batch = messages.slice(i, i + BATCH_SIZE);
          const batchResults = await Promise.all(
            batch.map(msg =>
              gapi.client.gmail.users.messages.get({
                userId: 'me',
                id: msg.id,
                format: 'full'
              })
            )
          );
          emails.push(...batchResults.map(e => e.result));
          userInfo.innerHTML = `⏳ Fetching emails… ${Math.min(i + BATCH_SIZE, messages.length)}/${messages.length}`;
        }

        // Filter by keywords
        let filteredEmails = filterEmailsByKeywords(emails);

        // Exclude specific senders that we don't want to process
        const excludedSenders = [
          'mignone',
          'student center',
          'griffin gsas bulletin',
          'harvard gazette'
        ];

        filteredEmails = filteredEmails.filter(email => {
          const headers = email.payload.headers;
          const from = (headers.find(h => h.name === 'From')?.value || '').toLowerCase();
          const subject = (headers.find(h => h.name === 'Subject')?.value || '').toLowerCase();

          // Exclude if from any of the excluded senders
          return !excludedSenders.some(sender => from.includes(sender) || subject.includes(sender));
        });

        const unprocessedCount = filteredEmails.filter(email => !processedEmailIds.has(email.id)).length;
        userInfo.innerHTML = `✓ Connected to Gmail - Found ${filteredEmails.length} potential event emails (${unprocessedCount} new, from ${emails.length} total)`;

        // Skip emails already sent to AI (prevents dismissed events from being re-added)
        const unprocessedEmails = filteredEmails.filter(email => !processedEmailIds.has(email.id));

        if (unprocessedEmails.length > 0) {
          await batchProcessEmails(unprocessedEmails);
        }

      } catch (err) {
        showError(`Failed to fetch emails: ${gapiError(err)}`);
        userInfo.innerHTML = '✓ Connected to Gmail';
      }
    }

    // Score an email for event likelihood. Returns a numeric score.
    function scoreEmail(email) {
      const headers = email.payload.headers;
      const subject = (headers.find(h => h.name === 'Subject')?.value || '').toLowerCase();
      const snippet = (email.snippet || '').toLowerCase();
      const body = extractEmailBody(email).toLowerCase();

      // Only apply negative signals to subject + snippet — NOT the full body.
      // Most legitimate event invite emails have "unsubscribe" in their footer,
      // and body text can contain incidental matches (e.g. "sign in to your account").
      const headerText = `${subject} ${snippet}`;
      if (NEGATIVE_KEYWORDS.some(kw => headerText.includes(kw))) return 0;

      let score = 0;

      // Strong keywords: worth 3 in subject, 3 in body
      for (const kw of STRONG_KEYWORDS) {
        if (subject.includes(kw)) score += 6; // 2× multiplier for subject
        else if (snippet.includes(kw) || body.includes(kw)) score += 3;
      }

      // Weak keywords: worth 2 in subject, 1 in body
      for (const kw of WEAK_KEYWORDS) {
        if (subject.includes(kw)) score += 2;
        else if (snippet.includes(kw) || body.includes(kw)) score += 1;
      }

      // Bonus if a date-like pattern appears in subject or snippet
      if (DATE_PATTERN.test(subject) || DATE_PATTERN.test(snippet)) score += 2;

      return score;
    }

    // Filter emails by keywords
    function filterEmailsByKeywords(emails) {
      return emails.filter(email => scoreEmail(email) >= MIN_SCORE);
    }

    // Mark an email as read
    async function markAsRead(messageId) {
      try {
        await gapi.client.gmail.users.messages.modify({
          userId: 'me',
          id: messageId,
          resource: {
            removeLabelIds: ['UNREAD']
          }
        });
      } catch (err) {
        // Silently fail - don't interrupt the flow if marking as read fails
        console.error('Failed to mark email as read:', err);
      }
    }

    // Batch process filtered emails — split into chunks to avoid Gemini rate limits
    const MAX_CHARS_PER_EMAIL = 4000; // ~1000 tokens per email (not applied to Mignone or Student Center emails)
    const GEMINI_BATCH_SIZE = 10; // emails per Gemini request

    async function batchProcessEmails(emails) {
      // Create progress indicator
      const progressDiv = document.createElement('div');
      progressDiv.className = 'bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4';
      progressDiv.innerHTML = `
        <div class="font-semibold text-gray-800 mb-2">Processing emails...</div>
        <div class="w-full bg-gray-200 rounded-full h-2">
          <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all" style="width: 0%"></div>
        </div>
        <div id="progressText" class="text-sm text-gray-600 mt-2"></div>
      `;
      eventsContainer.prepend(progressDiv);
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');

      // Mark all as processed upfront so they're never re-sent even if dismissed
      emails.forEach(email => processedEmailIds.add(email.id));
      localStorage.setItem('processedEmailIds', JSON.stringify([...processedEmailIds]));

      // Process all emails with Gemini
      for (let c = 0; c < emails.length; c += GEMINI_BATCH_SIZE) {
        const chunk = emails.slice(c, c + GEMINI_BATCH_SIZE);
        const batchNum = Math.floor(c / GEMINI_BATCH_SIZE) + 1;
        const totalBatches = Math.ceil(emails.length / GEMINI_BATCH_SIZE);

        // Update progress
        const progress = Math.round((c / emails.length) * 100);
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `Sending batch ${batchNum}/${totalBatches} (${chunk.length} emails) to Gemini...`;

        const gmailUrls = {};
        const emailContents = {};
        const sections = [];
        chunk.forEach((email, i) => {
          const idx = i + 1;
          const headers = email.payload.headers;
          const subject = headers.find(h => h.name === 'Subject')?.value || `Email ${idx}`;
          const from = headers.find(h => h.name === 'From')?.value || '';
          const date = headers.find(h => h.name === 'Date')?.value || '';
          const body = extractEmailBody(email);

          const truncatedBody = body.slice(0, MAX_CHARS_PER_EMAIL);
          if (!truncatedBody) return;
          gmailUrls[idx] = `https://mail.google.com/mail/u/0/#all/${email.threadId}`;
          const htmlBody = extractEmailHtmlBody(email);
          emailContents[idx] = { subject, from, date, body: body.slice(0, 3000), html: htmlBody };
          sections.push(`=== EMAIL ${idx}: ${subject} ===\n${truncatedBody}`);
        });

        if (sections.length === 0) continue;

        const combinedText = sections.join('\n\n');

        try {
          await extractEventsFromText(combinedText, true, gmailUrls, emailContents);

          // Mark all emails in this batch as read
          await Promise.all(chunk.map(email => markAsRead(email.id)));

          displayAllEvents();
        } catch (err) {
          showError(`Failed to process batch: ${err.message || err}`);
        }

        // Wait 2 seconds between batches to respect rate limits
        if (c + GEMINI_BATCH_SIZE < emails.length) {
          await new Promise(r => setTimeout(r, 2000));
        }
      }

      // Complete progress
      progressBar.style.width = '100%';
      progressText.textContent = `✓ Processing complete - ${emails.length} emails processed`;
      progressDiv.classList.remove('bg-blue-50', 'border-blue-200');
      progressDiv.classList.add('bg-green-50', 'border-green-200');

      displayAllEvents();
    }


    function extractEmailBody(email) {
      function decode(data) {
        return atob(data.replace(/-/g, '+').replace(/_/g, '/'));
      }

      // Recursively search for text content through nested multipart structures.
      // Returns { text, html } with the best candidates found anywhere in the tree.
      function findParts(payload) {
        const result = { text: '', html: '' };

        if (payload.mimeType === 'text/plain' && payload.body?.data) {
          result.text = decode(payload.body.data);
          return result;
        }
        if (payload.mimeType === 'text/html' && payload.body?.data) {
          result.html = decode(payload.body.data);
          return result;
        }

        for (const part of (payload.parts || [])) {
          const child = findParts(part);
          if (child.text) result.text = child.text;
          if (child.html) result.html = child.html;
          if (result.text) break; // prefer plain text, stop as soon as we have it
        }

        return result;
      }

      const { text, html } = findParts(email.payload);
      if (text) return text;
      if (html) return html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      return '';
    }

    // Extract the raw HTML body from an email (for display in modal)
    function extractEmailHtmlBody(email) {
      function decode(data) {
        return atob(data.replace(/-/g, '+').replace(/_/g, '/'));
      }
      function findHtml(payload) {
        if (payload.mimeType === 'text/html' && payload.body?.data) {
          return decode(payload.body.data);
        }
        for (const part of (payload.parts || [])) {
          const found = findHtml(part);
          if (found) return found;
        }
        return '';
      }
      return findHtml(email.payload);
    }

    // Initialize Google APIs when loaded
    if (typeof gapi !== 'undefined') {
      gapiLoaded();
    }
    if (typeof google !== 'undefined') {
      gisLoaded();
    }
    window.addEventListener('load', () => {
      if (typeof gapi !== 'undefined') gapiLoaded();
      if (typeof google !== 'undefined') {
        gisLoaded();
        // Try to restore previous session
        if (restoreSavedToken()) {
          // Valid saved token — just show signed-in UI
        } else if (localStorage.getItem('gmailUserSignedIn') === 'true') {
          // Token expired but user was previously signed in — try silent re-auth
          // (no popup shown if Google browser session is still active)
          tokenClient.requestAccessToken({ prompt: 'none' });
        }
      }
      // Display stored events on load
      displayAllEvents();
    });

    fetchUrlBtn.addEventListener('click', async () => {
      const url = urlInput.value.trim();
      if (!url) {
        showError('Please enter a URL first');
        return;
      }
      hideError();
      fetchUrlBtn.disabled = true;
      fetchUrlBtn.textContent = 'Fetching…';
      try {
        const res = await fetch('/api/fetch-url', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || res.statusText);
        emailInput.value = data.text;
      } catch (err) {
        showError(`Failed to fetch URL: ${err.message}`);
      } finally {
        fetchUrlBtn.disabled = false;
        fetchUrlBtn.textContent = 'Fetch URL';
      }
    });

    parseBtn.addEventListener('click', async () => {
      const emailText = emailInput.value.trim();

      if (!emailText) {
        showError('Please paste some email content first');
        return;
      }

      await extractEventsFromText(emailText, false);
      displayAllEvents();
    });

    // gmailUrls: either null (manual paste), a string (single email), or a {1: url, 2: url, ...} map (batch)
    async function extractEventsFromText(emailText, silent = false, gmailUrls = null, emailContents = null) {
      if (!silent) {
        setLoading(true);
        hideError();
      }

      try {
        // Call our secure backend proxy instead of Gemini API directly
        const response = await fetch('/api/extract-events', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            emailText: emailText
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`API Error: ${errorData.error || response.statusText}`);
        }

        const data = await response.json();
        const content = data.candidates[0].content.parts[0].text;
        const cleanContent = content.replace(/```json|```/g, '').trim();
        const events = JSON.parse(cleanContent);

        const now = new Date();
        let eventArray = (Array.isArray(events) ? events : [events])
          .filter(e => e.title)
          .filter(e => {
            if (!e.date) return true;
            const eventDate = buildEventDate(e.date, e.time);
            return eventDate >= now;
          });

        // Events from Mignone Center and Student Center are kept as individual event blocks (not consolidated)

        // Add events to global list
        eventArray.forEach(event => {
          // Add unique ID and timestamp
          event.id = Date.now() + Math.random();
          event.addedAt = new Date().toISOString();
          if (gmailUrls && typeof gmailUrls === 'object' && !Array.isArray(gmailUrls)) {
            let matchedIdx = null;
            // 1. Try Gemini's sourceEmailIndex
            if (gmailUrls[event.sourceEmailIndex]) {
              matchedIdx = event.sourceEmailIndex;
            } else {
              // 2. Match event title against each email section in the batch text
              const markerRe = /=== EMAIL (\d+):.*?===/g;
              const markers = [...emailText.matchAll(markerRe)];
              for (let mi = 0; mi < markers.length; mi++) {
                const idx = parseInt(markers[mi][1]);
                const start = markers[mi].index;
                const end = mi + 1 < markers.length ? markers[mi + 1].index : emailText.length;
                const section = emailText.substring(start, end).toLowerCase();
                if (event.title && section.includes(event.title.toLowerCase())) {
                  matchedIdx = idx;
                  break;
                }
              }
              // 3. Last resort: use the only entry if there's just one email
              if (!matchedIdx) {
                const keys = Object.keys(gmailUrls);
                if (keys.length === 1) matchedIdx = keys[0];
              }
            }
            if (matchedIdx) {
              event.gmailUrl = gmailUrls[matchedIdx];
              if (emailContents && emailContents[matchedIdx]) {
                event.emailContent = emailContents[matchedIdx];
              }
            }
          } else if (gmailUrls) {
            event.gmailUrl = gmailUrls;
          }

          // Check for duplicates (same title and date)
          const existing = allEvents.find(e =>
            e.title === event.title && e.date === event.date
          );

          if (existing) {
            // Retroactively add the Gmail link if we now have it
            if (!existing.gmailUrl && event.gmailUrl) {
              existing.gmailUrl = event.gmailUrl;
            }
          } else {
            allEvents.push(event);
          }
        });

        // Save to localStorage
        localStorage.setItem('extractedEvents', JSON.stringify(allEvents));

        if (!silent) {
          displayAllEvents();
        }
      } catch (err) {
        if (!silent) {
          showError(`Failed: ${err.message}`);
        }
        throw err;
      } finally {
        if (!silent) {
          setLoading(false);
        }
      }
    }

    function setLoading(loading) {
      parseBtn.disabled = loading;
      parseBtn.innerHTML = loading ? 
        '<svg class="animate-spin" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg> Parsing...' :
        '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg> Extract Events';
    }

    function showError(msg) {
      errorBox.textContent = msg;
      errorBox.classList.remove('hidden');
    }

    function hideError() {
      errorBox.classList.add('hidden');
    }

    // Helper function to format virtual meeting links with friendly names
    function formatVirtualLink(url) {
      if (!url) return null;
      const urlLower = url.toLowerCase();

      // Detect virtual meeting platforms
      if (urlLower.includes('zoom.us') || urlLower.includes('zoom.com')) {
        return { text: 'Zoom', url: url };
      }
      if (urlLower.includes('meet.google.com') || urlLower.includes('meet.app.goo.gl')) {
        return { text: 'Google Meet', url: url };
      }
      if (urlLower.includes('teams.microsoft.com') || urlLower.includes('teams.live.com')) {
        return { text: 'Microsoft Teams', url: url };
      }
      if (urlLower.includes('webex.com')) {
        return { text: 'Webex', url: url };
      }
      if (urlLower.includes('gotomeeting.com') || urlLower.includes('gotomeet.me')) {
        return { text: 'GoToMeeting', url: url };
      }
      if (urlLower.includes('bluejeans.com')) {
        return { text: 'BlueJeans', url: url };
      }
      if (urlLower.includes('whereby.com')) {
        return { text: 'Whereby', url: url };
      }

      // If it's a URL but not a known virtual platform, return full URL
      if (url.startsWith('http://') || url.startsWith('https://')) {
        return { text: url, url: url };
      }

      // Not a link, just plain text
      return null;
    }

    function displayAllEvents() {
      const now = new Date();

      // Clean up addedEventIds - remove events that have passed
      addedEventIds.forEach(eventId => {
        const event = allEvents.find(e => String(e.id) === String(eventId));
        if (event) {
          const eventDateTime = buildEventDate(event.date, event.time);
          if (eventDateTime < now) {
            addedEventIds.delete(String(eventId));
          }
        }
      });
      localStorage.setItem('addedEventIds', JSON.stringify([...addedEventIds]));

      // Filter out events that have been added to calendar
      const displayEvents = allEvents.filter(event =>
        !addedEventIds.has(String(event.id))
      );

      // Sort by date (upcoming first)
      const sortedEvents = displayEvents.sort((a, b) => {
        return new Date(a.date) - new Date(b.date);
      });

      // Show year only if events span more than one calendar year
      const years = new Set(sortedEvents.map(e => (e.date || '').split('-')[0]).filter(Boolean));
      const showYear = years.size !== 1;

      if (sortedEvents.length === 0) {
        eventsContainer.innerHTML = `
          <div class="bg-white rounded-xl shadow-lg p-8 text-center">
            <svg class="mx-auto mb-4 text-gray-400" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            <p class="text-gray-600 text-lg">No events found yet</p>
            <p class="text-gray-500 text-sm mt-2">Sign in and fetch emails to start extracting events</p>
          </div>
        `;
        return;
      }

      eventsContainer.innerHTML = `
        <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
          <div class="flex justify-between items-center">
            <h2 class="text-2xl font-bold text-gray-800">All Events (${sortedEvents.length})</h2>
            <button onclick="clearAllEvents()" class="px-4 py-2 bg-red-100 text-red-700 rounded-lg font-semibold hover:bg-red-200 transition-colors text-sm">
              Clear All
            </button>
          </div>
        </div>
        ${sortedEvents.map(event => renderEventCard(event, showYear)).join('')}
      `;
    }

    // Helper function to render an event card
    function renderEventCard(event, showYear) {
      return `
          <div class="bg-white rounded-xl shadow-lg p-6 hover:shadow-xl transition-shadow mb-4" id="event-${event.id}">
            <h3 class="text-xl font-bold text-gray-800 mb-4">${event.title}</h3>
            <div class="space-y-3">
              <div class="flex items-center gap-3 text-gray-700">
                <svg class="text-indigo-600" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                <span class="font-medium">${formatDateDisplay(event.date, showYear)}</span>
                ${event.time ? `
                  <svg class="text-indigo-600 ml-4" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
                  <span class="font-medium">${formatTimeDisplay(event.time)}</span>
                ` : ''}
              </div>
              ${event.host ? `
                <div class="flex items-center gap-3 text-gray-700">
                  <svg class="text-indigo-600" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                  <span>Hosted by ${event.host}</span>
                </div>
              ` : ''}
              ${event.location ? `
                <div class="flex items-center gap-3 text-gray-700">
                  <svg class="text-indigo-600" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                  ${(() => {
                    const virtualLink = formatVirtualLink(event.location);
                    if (virtualLink) {
                      return `<a href="${virtualLink.url}" target="_blank" class="text-indigo-600 hover:text-indigo-800 underline">${virtualLink.text}</a>`;
                    }
                    return `<span>${event.location}</span>`;
                  })()}
                </div>
              ` : ''}
              ${event.url ? `
                <div class="flex items-center gap-3 text-gray-700">
                  <svg class="text-indigo-600" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>
                  ${(() => {
                    const virtualLink = formatVirtualLink(event.url);
                    if (virtualLink && virtualLink.text !== event.url) {
                      // It's a virtual meeting link, show friendly name
                      return `<a href="${virtualLink.url}" target="_blank" class="text-indigo-600 hover:text-indigo-800 underline">${virtualLink.text}</a>`;
                    }
                    // Regular URL, show full link (but not breaking layout)
                    return `<a href="${event.url}" target="_blank" class="text-indigo-600 hover:text-indigo-800 underline break-all">${event.url}</a>`;
                  })()}
                </div>
              ` : ''}
              ${event.description ? `
                <div class="mt-4 p-4 bg-gray-50 rounded-lg">
                  <p class="text-gray-700 whitespace-pre-wrap">${event.description}</p>
                </div>
              ` : ''}
              ${event.emailContent ? `
                <div class="flex items-center gap-3 text-gray-700">
                  <svg class="text-indigo-600" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
                  <button onclick="viewOriginalEmail('${event.id}')" class="text-indigo-600 hover:text-indigo-800 underline text-sm bg-transparent border-none cursor-pointer p-0">View original email</button>
                </div>
              ` : ''}
            </div>
            <div class="flex gap-2 mt-4">
                <button onclick="addToCalendar('${event.id}', this)" class="px-4 py-2 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 flex items-center gap-2 transition-colors whitespace-nowrap text-sm">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                  Add to Calendar
                </button>
                <button onclick="dismissEvent('${event.id}')" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg font-semibold hover:bg-gray-300 flex items-center gap-2 transition-colors whitespace-nowrap text-sm">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                  Dismiss
                </button>
            </div>
          </div>
      `;
    }

    // Parse a time string (handles "16:00", "4:00 PM", "4 PM", etc.) into { hours, minutes }
    function parseTimeStr(timeStr) {
      if (!timeStr) return { hours: 0, minutes: 0 };
      const m = timeStr.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i);
      if (!m) return { hours: 0, minutes: 0 };
      let hours = parseInt(m[1]);
      const minutes = parseInt(m[2] || '0');
      const meridiem = (m[3] || '').toLowerCase();
      if (meridiem === 'pm' && hours !== 12) hours += 12;
      if (meridiem === 'am' && hours === 12) hours = 0;
      return { hours, minutes };
    }

    // Format a time string consistently as "2:00 PM" / "10:30 AM"
    function formatTimeDisplay(timeStr) {
      if (!timeStr) return '';
      const { hours, minutes } = parseTimeStr(timeStr);
      const period = hours < 12 ? 'AM' : 'PM';
      const h = hours % 12 || 12;
      const m = String(minutes).padStart(2, '0');
      return `${h}:${m} ${period}`;
    }

    // Format a YYYY-MM-DD date string as "Saturday, Mar 15 2026" (year optional)
    function formatDateDisplay(dateStr, showYear = true) {
      if (!dateStr) return dateStr;
      const [year, month, day] = dateStr.split('-').map(Number);
      const d = new Date(year, month - 1, day);
      if (isNaN(d.getTime())) return dateStr;
      const weekday = d.toLocaleDateString('en-US', { weekday: 'long' });
      const mon = d.toLocaleDateString('en-US', { month: 'short' });
      return showYear ? `${weekday}, ${mon} ${day} ${year}` : `${weekday}, ${mon} ${day}`;
    }

    // Build a local Date from event.date (YYYY-MM-DD) and event.time
    function buildEventDate(dateStr, timeStr) {
      const [year, month, day] = (dateStr || '').split('-').map(Number);
      const { hours, minutes } = parseTimeStr(timeStr);
      return new Date(year, month - 1, day, hours, minutes, 0);
    }

    // Add to calendar
    window.addToCalendar = async function(eventId, btn) {
      const event = allEvents.find(e => e.id == eventId);
      if (!event) return;

      // If signed in to Google, insert directly via Calendar API
      if (accessToken) {
        if (btn) { btn.disabled = true; btn.textContent = 'Adding…'; }
        try {
          // Ensure the token is set on the gapi client (may not be if it was
          // restored from localStorage before gapi finished initialising)
          gapi.client.setToken({ access_token: accessToken });

          if (!gapi.client.calendar) {
            throw new Error('Google Calendar API not loaded. Please refresh the page and try again.');
          }

          const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
          const startDt = buildEventDate(event.date, event.time);
          if (isNaN(startDt.getTime())) throw new Error(`Could not parse date/time: "${event.date}" "${event.time}"`);
          const endDt = new Date(startDt.getTime() + 60 * 60 * 1000); // +1 hour
          const insertResp = await gapi.client.calendar.events.insert({
            calendarId: 'primary',
            resource: {
              summary: event.title,
              location: event.location || '',
              description: [event.description, event.url ? `Link: ${event.url}` : ''].filter(Boolean).join('\n\n'),
              start: { dateTime: startDt.toISOString(), timeZone: tz },
              end:   { dateTime: endDt.toISOString(),   timeZone: tz },
            }
          });
          addedEventIds.add(String(event.id));
          localStorage.setItem('addedEventIds', JSON.stringify([...addedEventIds]));
          displayAllEvents(); // Refresh to remove event from list
        } catch (err) {
          if (btn) { btn.disabled = false; btn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg> Add to Calendar'; }
          const detail = err?.result?.error?.message || err?.message || String(err);
          const code = err?.result?.error?.code || err?.status || '';
          showError(`Failed to add to calendar${code ? ` (${code})` : ''}: ${detail}`);
          console.error('Calendar insert error:', err);
        }
        return;
      }

      // Not signed in — show options modal
      const optionsHTML = `
        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="this.remove()">
          <div class="bg-white rounded-xl shadow-2xl p-6 max-w-sm m-4" onclick="event.stopPropagation()">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Add to Calendar</h3>
            <div class="space-y-2">
              <button onclick="addToGoogleCalendar(${JSON.stringify(event).replace(/"/g, '&quot;')}); this.closest('.fixed').remove();" class="w-full px-4 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 flex items-center justify-center gap-2 transition-colors">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                Google Calendar
              </button>
<button onclick="this.closest('.fixed').remove()" class="w-full px-4 py-3 bg-gray-200 text-gray-700 rounded-lg font-semibold hover:bg-gray-300 transition-colors">
                Cancel
              </button>
            </div>
          </div>
        </div>
      `;
      document.body.insertAdjacentHTML('beforeend', optionsHTML);
    };

    // View original email in a modal
    window.viewOriginalEmail = function(eventId) {
      const event = allEvents.find(e => e.id == eventId);
      if (!event || !event.emailContent) return;
      const ec = event.emailContent;
      const escHtml = (s) => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');

      const bodyContent = ec.html
        ? `<iframe sandbox="allow-same-origin" class="w-full flex-1 border-0" style="min-height:300px"></iframe>`
        : `<div class="p-6 overflow-y-auto flex-1"><pre class="text-sm text-gray-700 whitespace-pre-wrap font-sans">${escHtml(ec.body)}</pre></div>`;

      const modalHTML = `
        <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onclick="this.remove()">
          <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-[80vh] flex flex-col" onclick="event.stopPropagation()">
            <div class="p-6 border-b border-gray-200 flex-shrink-0">
              <div class="flex justify-between items-start">
                <h3 class="text-lg font-bold text-gray-800 pr-4">${escHtml(ec.subject)}</h3>
                <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600 text-2xl leading-none">&times;</button>
              </div>
              <div class="mt-2 text-sm text-gray-600 space-y-1">
                <div><span class="font-medium">From:</span> ${escHtml(ec.from)}</div>
                <div><span class="font-medium">Date:</span> ${escHtml(ec.date)}</div>
              </div>
            </div>
            ${bodyContent}
          </div>
        </div>
      `;
      document.body.insertAdjacentHTML('beforeend', modalHTML);

      // If HTML email, write content into the sandboxed iframe
      if (ec.html) {
        const iframe = document.querySelector('.fixed iframe');
        iframe.srcdoc = ec.html;
      }
    };

    // Dismiss event
    window.dismissEvent = function(eventId) {
      allEvents = allEvents.filter(e => e.id != eventId);
      localStorage.setItem('extractedEvents', JSON.stringify(allEvents));
      addedEventIds.delete(String(eventId));
      localStorage.setItem('addedEventIds', JSON.stringify([...addedEventIds]));
      document.getElementById(`event-${eventId}`)?.remove();
      displayAllEvents();
    };

    // Clear all events
    window.relinkEmails = function() {
      autoFetchRecentEmails();
    };

    window.clearAllEvents = function() {
      if (confirm('Are you sure you want to clear all events?')) {
        allEvents = [];
        localStorage.setItem('extractedEvents', JSON.stringify(allEvents));
        addedEventIds.clear();
        localStorage.removeItem('addedEventIds');
        processedEmailIds.clear();
        localStorage.removeItem('processedEmailIds');
        displayAllEvents();
      }
    };

    function addToGoogleCalendar(event) {
      const toGCalStamp = (d) => d.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
      const startDt = buildEventDate(event.date, event.time || '00:00');
      const endDt = event.time
        ? new Date(startDt.getTime() + 60 * 60 * 1000)
        : buildEventDate(event.date, '23:59');
      const start = toGCalStamp(startDt);
      const end = toGCalStamp(endDt);
      const details = `${event.description || ''}${event.url ? '\n\nLink: ' + event.url : ''}`;
      
      const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(event.title)}&dates=${start}/${end}&details=${encodeURIComponent(details)}&location=${encodeURIComponent(event.location || '')}`;
      window.open(url, '_blank');
    }
  </script>
</body>
</html>